<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>GD zig-zag on ill-conditioned quadratic</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; }
    .row { display: flex; gap: 16px; align-items: center; flex-wrap: wrap; }
    canvas { border: 1px solid #ccc; border-radius: 8px; }
    .panel { display: flex; flex-direction: column; gap: 10px; max-width: 760px; }
    label { display: inline-flex; gap: 8px; align-items: center; }
    input[type="range"] { width: 260px; }
    code { background: #f6f6f6; padding: 2px 6px; border-radius: 6px; }
  </style>
</head>
<body>
  <h2>Gradient Descent: condition number ⇒ zig-zag tax</h2>

  <div class="row">
    <canvas id="cv" width="680" height="680"></canvas>

    <div class="panel">
      <div class="row">
        <label>
          γ (anisotropy)
          <input id="gamma" type="range" min="1" max="200" value="20" />
          <span id="gammaVal"></span>
        </label>
      </div>

      <div class="row">
        <label>
          Step rule
          <select id="rule">
            <option value="exact">Exact line search (quadratic)</option>
            <option value="fixed">Fixed step t = 1/M</option>
          </select>
        </label>
      </div>

      <div class="row">
        <button id="reset">Reset</button>
        <button id="step">Step</button>
        <button id="play">Play</button>
        <button id="pause">Pause</button>
      </div>

      <div>
        Model: <code>f(x1,x2)=0.5*(x1^2 + γ x2^2)</code>, gradient <code>g=[x1, γx2]</code>.
        <br/>
        For exact line search along <code>Δ=-g</code> (quadratic), step:
        <br/>
        <code>t = (gᵀg)/(gᵀQ g)</code> with <code>Q=diag(1,γ)</code>.
      </div>

      <div id="status"></div>
    </div>
  </div>

<script>
(() => {
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");

  const gammaSlider = document.getElementById("gamma");
  const gammaVal = document.getElementById("gammaVal");
  const ruleSel = document.getElementById("rule");
  const status = document.getElementById("status");

  const btnReset = document.getElementById("reset");
  const btnStep  = document.getElementById("step");
  const btnPlay  = document.getElementById("play");
  const btnPause = document.getElementById("pause");

  // World-to-canvas mapping
  function makeView(range) {
    const W = cv.width, H = cv.height;
    const pad = 40;
    return {
      range,
      toX(x) { return pad + (x + range) * (W - 2*pad) / (2*range); },
      toY(y) { return H - (pad + (y + range) * (H - 2*pad) / (2*range)); },
      fromX(px){ return (px - pad) * (2*range)/(W-2*pad) - range; },
      fromY(py){ return -((py - pad) * (2*range)/(H-2*pad) - range); }
    };
  }

  function f(x1, x2, gamma) { return 0.5*(x1*x1 + gamma*x2*x2); }
  function grad(x1, x2, gamma) { return [x1, gamma*x2]; }

  // For f = 0.5 x^T Q x, with Q=diag(1,gamma), gradient g=Qx.
  // Along direction -g: exact line search t = (g^T g)/(g^T Q g).
  function exactStepSize(x1, x2, gamma) {
    const g1 = x1, g2 = gamma*x2;
    const gTg = g1*g1 + g2*g2;
    const gTQg = g1*g1 + gamma*(g2*g2); // g^T Q g
    return (gTQg === 0) ? 0 : (gTg / gTQg);
  }

  let gamma = +gammaSlider.value;
  let x = [1.2, 1.0];        // start point (kept modest so plots remain visible)
  let path = [x.slice()];
  let playing = false;

  function reset() {
    gamma = +gammaSlider.value;
    // start point depends mildly on gamma to show different behavior but keep bounded
    x = [1.2, 1.0];
    path = [x.slice()];
    draw();
  }

  function stepOnce() {
    gamma = +gammaSlider.value;
    const [x1,x2] = x;
    const [g1,g2] = grad(x1,x2,gamma);

    const M = Math.max(1, gamma); // Hessian eigenvalues are 1 and gamma
    const rule = ruleSel.value;

    let t = 0;
    if (rule === "fixed") t = 1/M;
    else t = exactStepSize(x1,x2,gamma);

    // update x := x - t*g
    x = [x1 - t*g1, x2 - t*g2];
    path.push(x.slice());
    draw();
  }

  function drawContours(view) {
    // draw ellipses of constant f = c
    const levels = [0.05, 0.1, 0.2, 0.4, 0.8, 1.6];
    ctx.save();
    ctx.lineWidth = 1;

    for (const c of levels) {
      // f=0.5*(x1^2+gamma x2^2)=c  => x1 = sqrt(2c) cos, x2 = sqrt(2c/gamma) sin
      const a = Math.sqrt(2*c);
      const b = Math.sqrt(2*c / gamma);

      ctx.beginPath();
      const steps = 240;
      for (let i=0;i<=steps;i++){
        const t = (i/steps)*2*Math.PI;
        const X = a*Math.cos(t);
        const Y = b*Math.sin(t);
        const px = view.toX(X), py = view.toY(Y);
        if (i===0) ctx.moveTo(px,py);
        else ctx.lineTo(px,py);
      }
      ctx.strokeStyle = "#e6e6e6";
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawAxes(view) {
    ctx.save();
    ctx.strokeStyle = "#ddd";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(view.toX(-view.range), view.toY(0));
    ctx.lineTo(view.toX(view.range), view.toY(0));
    ctx.moveTo(view.toX(0), view.toY(-view.range));
    ctx.lineTo(view.toX(0), view.toY(view.range));
    ctx.stroke();
    ctx.restore();
  }

  function drawPath(view) {
    ctx.save();
    ctx.lineWidth = 2;

    // polyline
    ctx.beginPath();
    for (let i=0;i<path.length;i++){
      const [X,Y] = path[i];
      const px = view.toX(X), py = view.toY(Y);
      if (i===0) ctx.moveTo(px,py);
      else ctx.lineTo(px,py);
    }
    ctx.strokeStyle = "#111";
    ctx.stroke();

    // points
    for (let i=0;i<path.length;i++){
      const [X,Y] = path[i];
      const px = view.toX(X), py = view.toY(Y);
      ctx.beginPath();
      ctx.arc(px,py, (i===path.length-1)?5:3, 0, 2*Math.PI);
      ctx.fillStyle = (i===path.length-1) ? "#d11" : "#444";
      ctx.fill();
    }

    ctx.restore();
  }

  function draw() {
    gammaVal.textContent = gamma.toFixed(0);

    // choose view range to keep things visible as iterations proceed
    // Include start & current points; keep minimum range.
    let maxAbs = 1.6;
    for (const [X,Y] of path) maxAbs = Math.max(maxAbs, Math.abs(X), Math.abs(Y));
    const view = makeView(Math.min(6.0, Math.max(2.0, maxAbs*1.2)));

    ctx.clearRect(0,0,cv.width,cv.height);
    drawContours(view);
    drawAxes(view);
    drawPath(view);

    const fx = f(x[0], x[1], gamma);
    const kappa = Math.max(gamma, 1/gamma);
    status.innerHTML =
      `Iter: <b>${path.length-1}</b> &nbsp; ` +
      `f(x)=<b>${fx.toFixed(6)}</b> &nbsp; ` +
      `κ≈<b>${kappa.toFixed(1)}</b> (since eigenvalues are 1 and γ)`;
  }

  function tick() {
    if (playing) stepOnce();
    requestAnimationFrame(tick);
  }

  btnReset.onclick = reset;
  btnStep.onclick  = stepOnce;
  btnPlay.onclick  = () => playing = true;
  btnPause.onclick = () => playing = false;
  gammaSlider.oninput = () => { gamma = +gammaSlider.value; draw(); };
  ruleSel.onchange = () => draw();

  reset();
  tick();
})();
</script>
</body>
</html>
