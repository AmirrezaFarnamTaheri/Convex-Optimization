<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>KKT Vector Balance Widget</title>
  <style>
    body{margin:0;font-family:system-ui;background:#0b0d12;color:#e9eefc}
    .wrap{max-width:1000px;margin:20px auto;padding:0 14px}
    .row{display:grid;grid-template-columns:1.3fr .7fr;gap:12px}
    .card{background:#111626;border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:12px}
    canvas{width:100%;height:auto;display:block;border-radius:10px;background:#0a0f1f}
    label{display:block;margin-top:10px;color:#aab3c8}
    input{width:100%}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  </style>
</head>
<body>
<div class="wrap">
  <h2>KKT Stationarity as Vector Balance (2D)</h2>
  <div class="row">
    <div class="card">
      <canvas id="c" width="860" height="520"></canvas>
      <div class="mono" id="info"></div>
    </div>
    <div class="card">
      <div class="mono">
        Objective: f0(x,y) = (x-ax)^2 + (y-ay)^2  (a “bowl” centered at a)<br/>
        Constraint: g(x,y) = 1 - x - y ≤ 0  (equivalently x+y ≥ 1)
      </div>
      <label>Center a = (ax, ay)</label>
      <input id="ax" type="range" min="-0.2" max="1.5" step="0.01" value="0.2">
      <input id="ay" type="range" min="-0.2" max="1.5" step="0.01" value="0.2">

      <label>Show vectors at point x*</label>
      <div class="mono">
        At optimum on boundary: x* = projection of a onto line x+y=1 (if a violates constraint).<br/>
        λ* chosen so ∇f0(x*) + λ*∇g(x*) = 0.
      </div>
      <button id="toggle" style="margin-top:10px;padding:8px 10px;border-radius:10px;
        border:1px solid rgba(255,255,255,.1);background:#1a2444;color:#e9eefc;cursor:pointer;">
        Toggle vectors
      </button>
    </div>
  </div>
</div>

<script>
(() => {
  const c = document.getElementById("c");
  const ctx = c.getContext("2d");
  const axS = document.getElementById("ax");
  const ayS = document.getElementById("ay");
  const info = document.getElementById("info");
  const toggle = document.getElementById("toggle");
  let showVec = true;

  // Constraint: x+y >= 1  i.e. g(x,y)=1-x-y <=0
  // grad g = (-1,-1) everywhere.

  function projToLine(a){
    // Project point a onto line x+y=1.
    // Line normal n=(1,1). For line n·x=1.
    // Projection: x* = a - ((n·a - 1)/(||n||^2)) n
    const nx=1, ny=1;
    const dot = nx*a.x + ny*a.y;
    const t = (dot - 1) / (nx*nx + ny*ny);
    return {x: a.x - t*nx, y: a.y - t*ny};
  }

  function drawArrow(x0,y0,x1,y1,label){
    ctx.beginPath();
    ctx.moveTo(x0,y0); ctx.lineTo(x1,y1);
    ctx.stroke();
    // arrowhead
    const dx=x1-x0, dy=y1-y0;
    const L=Math.hypot(dx,dy) || 1;
    const ux=dx/L, uy=dy/L;
    const ah=10;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x1 - ah*(ux*0.9 - uy*0.4), y1 - ah*(uy*0.9 + ux*0.4));
    ctx.lineTo(x1 - ah*(ux*0.9 + uy*0.4), y1 - ah*(uy*0.9 - ux*0.4));
    ctx.closePath();
    ctx.fill();
    ctx.fillText(label, x1+6, y1+6);
  }

  function mapX(x){ return 60 + (x - (-0.4))*(c.width-90)/(1.8-(-0.4)); }
  function mapY(y){ return (c.height-60) - (y - (-0.4))*(c.height-100)/(1.8-(-0.4)); }

  function render(){
    const a = {x: parseFloat(axS.value), y: parseFloat(ayS.value)};
    // Feasible if a.x+a.y >=1. If feasible, unconstrained optimum is a itself.
    let xstar = {x:a.x, y:a.y};
    let active = false;
    if (a.x + a.y < 1){
      xstar = projToLine(a);
      active = true;
    }

    // Gradients at x*
    // f0 = (x-ax)^2+(y-ay)^2 => ∇f0 = 2(x-ax, y-ay)
    const gradf = {x: 2*(xstar.x - a.x), y: 2*(xstar.y - a.y)};
    const gradg = {x: -1, y: -1};

    // Choose λ so gradf + λ gradg = 0 (only meaningful if active)
    let lam = 0;
    if (active){
      // gradf is parallel to (1,1) at projection; solve using one coordinate:
      // gradf_x + λ(-1)=0 => λ = gradf_x
      lam = gradf.x; // should match gradf.y
      if (lam < 0) lam = 0; // numerical safety
    }

    ctx.clearRect(0,0,c.width,c.height);

    // axes box
    ctx.strokeStyle="rgba(255,255,255,0.18)";
    ctx.strokeRect(50,40,c.width-80,c.height-90);

    // feasible half-plane shading x+y>=1
    ctx.fillStyle="rgba(60,120,255,0.10)";
    // draw polygon of feasible region in view window
    const corners = [
      {x:-0.4,y:-0.4},{x:1.8,y:-0.4},{x:1.8,y:1.8},{x:-0.4,y:1.8}
    ];
    // clip to x+y>=1 by brute-sampling grid (simple + robust)
    const step=6;
    for(let px=50; px<c.width-30; px+=step){
      for(let py=40; py<c.height-50; py+=step){
        // inverse map approx
        const x = -0.4 + (px-60)*(1.8+0.4)/(c.width-90);
        const y = -0.4 + ((c.height-60)-py)*(1.8+0.4)/(c.height-100);
        if (x+y>=1) ctx.fillRect(px,py,step,step);
      }
    }

    // boundary line x+y=1
    ctx.strokeStyle="rgba(255,255,255,0.65)";
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    // y=1-x
    const p1={x:-0.4,y:1.4}, p2={x:1.8,y:-0.8};
    ctx.moveTo(mapX(p1.x),mapY(p1.y));
    ctx.lineTo(mapX(p2.x),mapY(p2.y));
    ctx.stroke();
    ctx.setLineDash([]);

    // draw center a and optimum x*
    ctx.fillStyle="rgba(255,220,140,0.95)";
    ctx.beginPath(); ctx.arc(mapX(a.x),mapY(a.y),6,0,Math.PI*2); ctx.fill();
    ctx.fillText("a (unconstrained minimizer)", mapX(a.x)+10, mapY(a.y)-8);

    ctx.fillStyle="rgba(170,220,255,1)";
    ctx.beginPath(); ctx.arc(mapX(xstar.x),mapY(xstar.y),6,0,Math.PI*2); ctx.fill();
    ctx.fillText("x*", mapX(xstar.x)+10, mapY(xstar.y)-8);

    // vectors: grad f0 and λ grad g
    if (showVec){
      const scale = 0.35; // visual scaling
      const baseX = mapX(xstar.x), baseY=mapY(xstar.y);

      // grad f0 arrow
      ctx.strokeStyle="rgba(255,255,255,0.85)";
      ctx.fillStyle="rgba(255,255,255,0.85)";
      drawArrow(baseX,baseY, baseX + scale*gradf.x*100, baseY - scale*gradf.y*100, "∇f0(x*)");

      // lambda grad g arrow
      ctx.strokeStyle="rgba(170,220,255,0.95)";
      ctx.fillStyle="rgba(170,220,255,0.95)";
      const vg = {x: lam*gradg.x, y: lam*gradg.y};
      drawArrow(baseX,baseY, baseX + scale*vg.x*100, baseY - scale*vg.y*100, "λ*∇g(x*)");
    }

    info.innerHTML =
      `<div class="mono">
      active constraint: ${active ? "YES (x+y=1)" : "NO (interior feasible)"}<br/>
      x* = (${xstar.x.toFixed(3)}, ${xstar.y.toFixed(3)})<br/>
      λ* = ${lam.toFixed(3)}<br/>
      ∇f0(x*) = (${gradf.x.toFixed(3)}, ${gradf.y.toFixed(3)})<br/>
      ∇g(x*) = (-1,-1) (constant)
      </div>`;
  }

  toggle.onclick = () => { showVec=!showVec; render(); };
  axS.oninput = render; ayS.oninput = render;
  render();
})();
</script>
</body>
</html>
